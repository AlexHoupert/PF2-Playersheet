<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinder 2e Digital Sheet</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Roboto:wght@400;700;900&display=swap');

        :root {
            --bg-dark: #1a1a1d;
            --bg-panel: #2b2b2e;
            --text-gold: #c5a059;
            --text-light: #e0e0e0;
            --text-dim: #aaa;
            --accent-red: #d32f2f;
            --accent-green: #2e7d32;
            --accent-blue: #42a5f5;
            --border-color: #5c4033;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-light);
            font-family: 'Roboto', sans-serif;
            margin: 0; padding: 10px;
            max-width: 800px;
            margin-left: auto; margin-right: auto;
            padding-bottom: 80px; /* Extra space for bottom lists */
        }

        h1, h2, h3 { font-family: 'Cinzel', serif; color: var(--text-gold); margin: 5px 0; }
        
        /* SEPARATORS */
        .section-separator {
            border-bottom: 2px solid var(--border-color); 
            margin: 5px 0 15px 0; width: 100%;
        }

        /* HEADER */
        .header-bar {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid var(--text-gold);
            padding-bottom: 10px; margin-bottom: 15px; 
        }
        .header-controls {
            display: flex; align-items: center; gap: 8px;
        }
        .gold-display {
            font-size:1.2em; color:var(--text-gold); cursor: pointer; 
            padding: 5px 10px; border-radius: 4px; border: 1px solid rgba(197, 160, 89, 0.3);
            display: flex; align-items: center; gap: 5px; background: rgba(0,0,0,0.2);
        }
        .btn-char-switch {
            background: var(--bg-panel); border: 1px solid var(--border-color);
            color: var(--text-light); font-size: 1.2em; padding: 5px 10px;
            border-radius: 4px; cursor: pointer; display: flex; align-items: center;
            transition: 0.2s;
        }
        .btn-char-switch:hover { border-color: var(--text-gold); color: var(--text-gold); }

        /* TABS */
        .tabs { display: flex; gap: 5px; margin-bottom: 15px; } 
        .tab-btn {
            background: var(--bg-panel); color: var(--text-light);
            border: 1px solid var(--border-color); flex: 1; padding: 10px;
            cursor: pointer; font-family: 'Cinzel', serif; text-transform: uppercase;
        }
        .tab-btn.active { background: var(--text-gold); color: var(--bg-dark); font-weight: bold; border-color: var(--text-gold); }
        .view-section { display: none; animation: fadeIn 0.3s; }
        .view-section.active { display: block; }

        /* SUB TABS (Actions & Items) */
        .sub-tabs { 
            display: flex; gap: 5px; margin-bottom: 10px; padding: 0 5px; 
            margin-top: -10px; /* Pulls sub-tabs closer to main tabs */
        }
        .sub-tab-btn {
            background: #222; color: #888; border: 1px solid #444; flex: 1; padding: 6px;
            cursor: pointer; font-family: 'Roboto', sans-serif; font-size: 0.8em; text-transform: uppercase;
            border-radius: 4px; transition: 0.2s;
        }
        .sub-tab-btn.active { background: #444; color: var(--text-gold); border-color: var(--text-gold); font-weight: bold; }

        /* --- HEALTH BAR --- */
        .health-section { margin-bottom: 20px; text-align: center; position: relative; padding-bottom: 10px; }
        .bar-container {
            width: 100%; 
            height: 24px; 
            background: #111; 
            border: 2px solid var(--text-gold); border-radius: 6px;
            position: relative; overflow: hidden; cursor: pointer;
            box-shadow: 0 0 15px rgba(0,0,0,0.8); z-index: 1;
        }
        .bar-fill { height: 100%; width: 100%; background-color: #4caf50; transition: width 0.4s ease, background-color 0.4s ease; }
        .bar-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Cinzel', serif; font-weight: bold; font-size: 1.2em;
            text-shadow: 2px 2px 0px #000, -1px -1px 0 #000; z-index: 3; pointer-events: none;
        }
        .temp-bar-container {
            position: absolute; bottom: -5px; left: 0; height: 20px;
            background: rgba(0,0,0,0.5); border: 1px solid #90caf9; border-left: none;
            border-radius: 0 4px 4px 0; z-index: 2; box-shadow: 0 0 8px #2196f3;
            cursor: pointer; transition: opacity 0.3s ease, width 0.3s ease; overflow: hidden; width: 100%;
        }
        .temp-bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #1e88e5, #42a5f5, #90caf9); transition: width 0.3s ease; }
        .temp-text {
            position: absolute; top:0; left:5px; height:100%; display:flex; align-items:center; 
            font-size:0.8em; font-weight:bold; color: white; text-shadow: 1px 1px 2px black;
        }

        /* --- DEFENSES --- */
        .defenses-grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 5px;
            align-items: stretch;
        }
        .stat-box {
            background: var(--bg-panel); border: 1px solid var(--border-color); 
            padding: 5px 2px; text-align: center; border-radius: 4px;
            display: flex; flex-direction: column; justify-content: center;
        }
        .stat-val { font-size: 1.4em; font-weight: bold; color: var(--text-gold); line-height: 1.1; }
        .stat-label { font-size: 0.6em; text-transform: uppercase; color: #888; margin-top: 2px; }
        .stat-penalty { color: #ef5350 !important; }
        .stat-penalty-sub { font-size: 0.6em; color: #ef5350; vertical-align: middle; }

        /* AC Shield */
        .shield-box {
            background: linear-gradient(135deg, #3a3a3e, #222);
            border: 2px solid var(--border-color); border-top: none;
            border-radius: 4px 4px 50% 50%; padding-bottom: 10px; 
            box-shadow: inset 0 0 10px #000; position: relative; 
            cursor: pointer; /* Clickable now */
        }
        .shield-label { color: var(--text-gold); font-family: 'Cinzel', serif; }

        .shield-bonus-badge {
            position: absolute; top: 50%; right: -6px; transform: translateY(-50%);
            width: 24px; height: 24px; background: #333; border: 2px solid var(--text-gold);
            border-radius: 50%; color: var(--text-gold);
            font-size: 0.8em; font-weight: bold; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5); z-index: 10;
        }
        .broken-stat { text-decoration: line-through; color: var(--accent-red) !important; border-color: var(--accent-red) !important; }

        /* SHIELD STATUS ROW */
        .shield-status-row {
            margin-top: 15px; background: rgba(0,0,0,0.2); border: 1px solid #444; border-radius: 4px;
            padding: 5px 10px; display: flex; align-items: center; gap: 10px; font-size: 0.9em;
            cursor: pointer;
        }
        .shield-status-row:hover { background: rgba(255,255,255,0.05); }
        .shield-hp-bar {
            flex-grow: 1; height: 10px; background: #222; border-radius: 5px; overflow: hidden; position: relative;
        }
        .shield-fill { height: 100%; background: #777; transition: width 0.3s; }
        .shield-text { font-family: 'Roboto', sans-serif; color: #ccc; }
        .shield-break-marker {
            position: absolute; left: 50%; top: 0; bottom: 0; width: 2px; background-color: rgba(0,0,0,0.8); z-index: 5;
        }

        /* --- CONDITIONS AREA --- */
        .conditions-area { margin-top: 15px; display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 6px; }
        .btn-condition-add {
            grid-column: span 2; width: 80%; padding: 4px 8px; background: #222; border: 1px dashed #666;
            color: #888; font-family: 'Cinzel', serif; cursor: pointer; border-radius: 20px;
            transition: 0.2s; text-align: center; min-height: 24px; justify-self: center;
        }
        .btn-condition-add:hover { background: #333; color: var(--text-gold); border-color: var(--text-gold); }
        
        .condition-badge {
            background: rgba(211, 47, 47, 0.12);
            border: 1px solid var(--accent-red);
            border-radius: 20px;
            padding: 4px 8px;
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: 0.2s;
            min-height: 24px;
        }
        .condition-badge.cond-positive { background: rgba(46, 125, 50, 0.12); border-color: var(--accent-green); }
        .condition-badge.cond-visibility { background: rgba(66, 165, 245, 0.12); border-color: var(--accent-blue); }
        .condition-badge:hover { background: rgba(211, 47, 47, 0.25); }
        .condition-badge.cond-positive:hover { background: rgba(46, 125, 50, 0.25); }
        .condition-badge.cond-visibility:hover { background: rgba(66, 165, 245, 0.25); }
        .cond-icon { width: 22px; height: 22px; filter: invert(1); opacity: 0.85; }
        .cond-name { font-weight: bold; text-transform: uppercase; color: #ff8a80; font-size: 0.85em; line-height: 1.2; }
        .condition-badge.cond-positive .cond-name { color: #9ae6a0; }
        .condition-badge.cond-visibility .cond-name { color: #b3e5ff; }
        .cond-level { font-weight: 900; font-size: 1.1em; color: white; }
        .cond-level-hidden { display: none; }

        /* --- SPLIT LAYOUT --- */
        .layout-split {
            display: grid; 
            grid-template-columns: 80px 1fr; 
            gap: 15px; 
            align-items: start;
        }

        .attr-col { display: flex; flex-direction: column; gap: 8px; align-items: center; }
        .attr-box {
            background: var(--bg-panel); border: 1px solid var(--border-color); 
            width: 100%; padding: 8px 0; text-align: center; border-radius: 4px;
        }
        
        /* PERCEPTION (Eye) */
        .eye-container {
            width: 60px; height: 60px; 
            margin-top: 5px;
            background: #151515; border: 2px solid var(--text-gold);
            border-radius: 75% 15% 75% 15%; 
            transform: rotate(45deg); 
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 10px rgba(197, 160, 89, 0.2);
            cursor: pointer; z-index: 2; position: relative;
        }
        .eye-content { transform: rotate(-45deg); text-align: center; margin-top: 0; margin-left: 0; }

        /* SENSES BOX */
        .senses-box {
            width: 100%; background: #222; border: 1px solid #444; border-radius: 8px;
            padding: 22px 5px 8px 5px; margin-top: -30px; 
            z-index: 1; position: relative;
            text-align: center; font-size: 0.75em; color: #aaa; line-height: 1.3;
        }

        /* SPEED CIRCLE */
        .speed-circle {
            width: 70px; height: 70px; 
            background: var(--bg-panel); border: 2px solid var(--border-color);
            border-radius: 50%; display: flex; flex-direction: column; align-items: center; justify-content: center;
            margin-top: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); cursor: pointer;
        }
        .speed-circle:hover { border-color: var(--text-gold); }

        /* CLASS DC (Diamond) */
        .class-dc-box {
            width: 50px; height: 50px; background: #222;
            border: 2px solid var(--text-gold);
            transform: rotate(45deg);
            display: flex; align-items: center; justify-content: center;
            margin: 15px 0 10px 0; /* Spacing */
            box-shadow: inset 0 0 10px #000;
        }
        .class-dc-content { transform: rotate(-45deg); text-align: center; }

        /* LANGUAGES BOX */
        .languages-box {
            width: 100%; background: #222; border: 1px solid #444; border-radius: 8px;
            padding: 8px; margin-top: 5px;
            text-align: center; font-size: 0.75em; color: #ccc; line-height: 1.4;
        }
        .lang-label {
            font-size: 0.8em; text-transform: uppercase; color: #666; 
            border-bottom: 1px solid #333; margin-bottom: 4px; padding-bottom: 2px;
        }

        /* SKILLS LIST */
        .skills-container { display: grid; grid-template-columns: 1fr; gap: 6px; }
        .item-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 12px; border-bottom: 1px solid var(--border-color);
            background: rgba(255,255,255,0.02);
        }
        .item-name { font-weight: bold; cursor: pointer; color: #ccc; display: flex; align-items: center; gap: 4px; }
        .skill-val { font-family: 'Roboto', sans-serif; font-size: 1.1em; font-weight: 900; }
        .skill-trained { color: var(--text-gold); }
        .skill-untrained { color: var(--text-dim); opacity: 0.8; }
        .action-bonus { font-weight: 900; color: var(--text-gold); font-size: 1.1em; }
        
        /* ACTION HEADERS */
        .action-section-header {
            background: transparent;
            color: var(--text-gold);
            font-family: 'Cinzel', serif;
            padding: 5px 0;
            margin: 20px 0 5px 0;
            border-bottom: 2px solid var(--border-color);
            font-weight: bold;
            text-transform: uppercase;
        }

        /* WEAPON ROWS */
        .weapon-entry {
            display: flex; flex-direction: column; gap: 4px;
            padding: 8px 12px; border-bottom: 1px solid var(--border-color);
            background: rgba(255,255,255,0.02); cursor: pointer;
        }
        .weapon-top { display: flex; justify-content: space-between; align-items: center; }
        .weapon-bot { display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; color: var(--text-dim); }
        .w-bonus { color: var(--text-gold); font-weight: 900; font-size: 1.1em; }
        .w-ammo { color: #888; font-family: 'Roboto', sans-serif; }
        .w-damage { color: #e0e0e0; font-style: italic; }

        /* BARREL / GUN UI */
        .barrel-container { display: flex; gap: 4px; align-items: center; margin: 0 10px; }
        .barrel-opt {
            width: 12px; height: 12px; border-radius: 50%;
            border: 2px solid var(--text-gold); cursor: pointer;
            background: transparent; transition: 0.2s;
            box-shadow: 0 0 2px #000;
        }
        .barrel-opt.loaded { background: var(--text-gold); box-shadow: 0 0 5px var(--text-gold); }
        .barrel-opt:hover { border-color: #fff; }

        /* BUTTONS & MODALS */
        .btn-buy { padding:6px 12px; background:var(--accent-red); color:white; border:none; border-radius:3px; cursor:pointer; font-weight:bold; }
        .btn-add { padding:6px 12px; background:var(--accent-green); color:white; border:none; border-radius:3px; cursor:pointer; margin-right:5px; font-weight:bold; }

        .modal {
            display: none; position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.85); justify-content: center; align-items: center; z-index: 99;
        }
        #infoModal { z-index: 120; }
        .modal-box {
            background: var(--bg-panel); padding: 20px; border: 2px solid var(--text-gold);
            width: 90%; max-width: 400px; box-shadow: 0 0 20px #000; position: relative; border-radius: 5px;
            max-height: 80vh; overflow-y: auto; /* Scroll for conditions */
        }
        .qty-control-box { display: flex; align-items: center; justify-content: center; gap: 10px; margin: 20px 0; }
        .qty-btn {
            background: var(--bg-dark); color: var(--text-gold);
            border: 1px solid var(--text-gold); font-size: 29px; width: 54px; height: 54px; border-radius: 6px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
        }
        .input-resource {
            background: var(--bg-dark); color: white; border: 1px solid #666;
            font-size: 1.5em; padding: 5px; width: 100px; text-align: center; border-radius: 5px;
        }
        .set-btn {
            width: 100%; background: #444; color: white; border: none; padding: 10px;
            font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
            margin-top: 10px; border-radius: 4px;
        }
        .modal-footer-btn {
            width: 100%; background: #333; color: var(--text-light); border: 1px solid #555;
            padding: 10px; margin-top: 15px; cursor: pointer; font-family: 'Cinzel', serif;
        }
        .modal-equip-btn {
            width: 100%; background: var(--text-gold); color: var(--bg-dark); border: none;
            padding: 10px; margin-top: 10px; cursor: pointer; font-weight: bold; text-transform: uppercase;
        }

        .qty-badge { font-size: 1.1em; padding: 5px 12px; background: rgba(0,0,0,0.3); border-radius: 4px; cursor: pointer; border: 1px solid transparent; }
        .hp-input-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 10px 0; }
        .hp-input-row label { color: #ccc; font-size: 0.9em; }
        .hp-input-row input { width: 120px; padding: 6px; background: var(--bg-dark); border: 1px solid #666; color: white; border-radius: 4px; font-size: 1em; text-align: center; }
        
        /* TOGGLES */
        .toggle-row { display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(255,255,255,0.05); margin-bottom: 8px; border-radius: 4px; }
        .toggle-label { font-weight: bold; color: #ccc; }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--text-gold); }
        input:checked + .slider:before { transform: translateX(26px); }

        /* CONDITION MODAL ITEMS */
        .cond-modal-row {
            display: flex; align-items: center; justify-content: space-between;
            padding: 8px; border-bottom: 1px solid #444;
        }
        .cond-modal-left { display: flex; align-items: center; gap: 10px; flex-grow: 1; cursor: pointer; }
        .cond-chevron {
            font-size: 1.5em; font-weight: bold; cursor: pointer; padding: 0 10px; color: var(--text-gold); user-select: none;
        }
        .cond-chevron.disabled { color: #444; cursor: default; }
        .cond-val-disp { width: 20px; text-align: center; font-weight: bold; font-size: 1.2em; }
        .cond-tabs { display: flex; gap: 6px; margin-bottom: 8px; }
        .cond-tab-btn { flex: 1; padding: 8px; background: #222; border: 1px solid #444; color: #ccc; cursor: pointer; border-radius: 4px; text-align: center; font-size: 0.9em; }
        .cond-tab-btn.active { background: var(--text-gold); color: var(--bg-dark); border-color: var(--text-gold); }

        /* PF2E ACTION ICONS */
        .pf-icon {
            display: inline-block;
            height: 1.1em;
            width: auto;
            vertical-align: text-bottom;
            position: relative;
            top: 1px;
            fill: var(--text-gold); /* Icons color matches gold theme */
        }
        
        /* MAGIC TAB STYLES */
        .magic-stat-block { 
            margin-bottom: 15px; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            gap: 10px; 
        }
        
        /* Spell DC Hexagon */
        .hex-box {
            width: 70px; height: 75px;
            background: #222;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative;
            box-shadow: 0 0 10px var(--text-gold); 
        }
        .hex-content { text-align: center; z-index: 2; margin-top: -2px;}
        
        .spell-attack-box {
            background: var(--bg-panel); border: 2px solid var(--border-color);
            padding: 5px 0; border-radius: 4px; text-align: center;
            width: 70px; /* Same as hex width */
            box-sizing: border-box;
        }

        .magic-split { display: grid; grid-template-columns: 80px 1fr; gap: 15px; align-items: start; }
        
        /* Compact Slot Box */
        .slot-box {
            background: var(--bg-panel); border: 1px solid var(--border-color);
            border-radius: 4px; padding: 1px; margin-bottom: 4px;
            text-align: center;
            width: 100%; box-sizing: border-box;
        }
        .slot-title { font-size: 0.6em; text-transform: uppercase; color: #888; margin-bottom: 2px; }
        
        /* Updated Checkbox Layout:
           A 45deg rotated 14px box has a visual width of approx 20px.
           To fit 2 in a row, we need width > 40px + gaps. 
           We use flex-wrap with a container width that forces wrap after 2 items.
        */
        .slot-checks { 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; 
            gap: 3px; /* Gap between boxes */
            width: 52px; /* Increased to fix stacking issue (2 items ~ 50px) */
            margin: 0 auto;
            padding: 2px 0;
        }
        
        .slot-check {
            width: 14px; height: 14px; background: #111; 
            border: 1px solid var(--text-gold); 
            transform: rotate(45deg); 
            cursor: pointer;
            margin: 4px; /* Increased margin to prevent corner overlap */
        }
        .slot-check.active { background: var(--text-gold); box-shadow: 0 0 5px var(--text-gold); }

        .spell-list-header { 
            background: transparent; padding: 5px 0;
            font-family: 'Cinzel', serif; font-size: 1.1em; color: var(--text-gold);
            margin-top: 15px; border-bottom: 2px solid var(--border-color);
            font-weight: bold;
        }
        .spell-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 10px; border-bottom: 1px solid #333; cursor: pointer;
        }
        .spell-row:hover { background: rgba(255,255,255,0.03); }
        .spell-meta { display: flex; align-items: center; gap: 8px; font-size: 0.8em; color: #888; }
        .bloodline-drop { color: var(--accent-red); margin-left: 5px; font-size: 0.9em; }
        
        /* Character Switcher Styles */
        .char-item-row { padding: 12px; border-bottom: 1px solid #444; font-size: 1.1em; cursor: pointer; display: flex; justify-content: space-between; }
        .char-item-row:hover { background: rgba(255,255,255,0.1); color: var(--text-gold); }
        .char-item-active { color: var(--text-gold); font-weight: bold; }

        #loading { text-align: center; margin-top: 50px; font-style: italic; color: #888; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>

<div id="loading">Consulting the Archives...</div>

<div id="app" style="display:none;">
    
    <div class="header-bar">
        <div>
            <h1 id="uiName">Character</h1>
            <small>Level <span id="uiLevel">1</span> | XP: <span id="uiXP">0</span></small>
        </div>
        <div class="header-controls">
            <!-- Char Switch Button -->
            <button class="btn-char-switch" onclick="openCharModal()">ðŸ‘¥</button>
            <div class="gold-display" onclick="openResourceModal('Gold')">
                <span>ðŸ’°</span> <span id="uiGold">0</span> gp
            </div>
        </div>
    </div>

    <div class="tabs">
        <button class="tab-btn active" onclick="setTab('main')">Stats</button>
        <button class="tab-btn" onclick="setTab('actions')">Actions</button>
        <button class="tab-btn" onclick="setTab('feats')">Feats</button>
        <button class="tab-btn" id="btnMagic" style="display:none;" onclick="setTab('magic')">Magic</button>
        <button class="tab-btn" onclick="setTab('items')">Items</button>
    </div>

    <div id="view-main" class="view-section active">
        
        <div class="health-section">
            <div class="bar-container" onclick="openResourceModal('HP')">
                <div id="hpBarFill" class="bar-fill"></div>
                <div class="bar-text"><span id="uiHP">0</span> / <span id="uiMaxHP">0</span></div>
            </div>
            <div id="tempHpArea">
                <div id="barTempHP" class="temp-bar-container" style="display:none;" onclick="openResourceModal('HP')">
                    <div class="temp-bar-fill"></div>
                    <div class="temp-text">+<span id="uiTempHP">0</span> Temp HP</div>
                </div>
            </div>
        </div>

        <div class="conditions-area" id="conditionsArea"></div>

        <h3>Defenses</h3>
        <div class="section-separator" style="margin-top:0;"></div>
        
        <div class="defenses-grid" id="savesGrid"></div>
        
        <div id="shieldStatusArea"></div>

        <h3 style="margin-top:20px;">Attributes & Skills</h3>
        <div class="section-separator" style="margin-top:0;"></div>

        <div class="layout-split">
            
            <div class="attr-col">
                <div class="attr-box"><div class="stat-val" id="uiStr">0</div><div class="attr-label">STR</div></div>
                <div class="attr-box"><div class="stat-val" id="uiDex">0</div><div class="attr-label">DEX</div></div>
                <div class="attr-box"><div class="stat-val" id="uiCon">0</div><div class="attr-label">CON</div></div>
                <div class="attr-box"><div class="stat-val" id="uiInt">0</div><div class="attr-label">INT</div></div>
                <div class="attr-box"><div class="stat-val" id="uiWis">0</div><div class="attr-label">WIS</div></div>
                <div class="attr-box"><div class="stat-val" id="uiCha">0</div><div class="attr-label">CHA</div></div>
                
                <div style="width: 80%; height: 1px; background: #444; margin: 5px 0;"></div>

                <div class="eye-container" id="uiPerBox">
                    <div class="eye-content">
                        <div class="stat-val" id="uiPer" style="font-size:1.2em; line-height:1;">0</div>
                        <div class="stat-label" style="font-size:0.5em;">PERCEPT</div>
                    </div>
                </div>

                <div id="uiSenses" class="senses-box" style="display:none;"></div>

                <div class="speed-circle" onclick="showSpeedDetails()">
                    <div class="stat-val" id="uiSpeed" style="font-size:1.3em;">25</div>
                    <div class="stat-label" style="font-size:0.5em;">SPEED</div>
                </div>

                <div class="class-dc-box">
                    <div class="class-dc-content">
                        <div class="stat-val" id="uiClassDC" style="font-size:1.1em; line-height:1;">10</div>
                        <div class="stat-label" style="font-size:0.4em;">CLASS DC</div>
                    </div>
                </div>
                
                <div id="uiLanguages" class="languages-box" style="display:none;"></div>

            </div>

            <div id="skillsList" class="skills-container"></div>
        </div>

    </div>

    <div id="view-actions" class="view-section">
        <div class="sub-tabs">
            <button class="sub-tab-btn active" onclick="setSubTab('Combat')">Combat</button>
            <button class="sub-tab-btn" onclick="setSubTab('Movement')">Movement</button>
            <button class="sub-tab-btn" onclick="setSubTab('Skill')">Skill</button>
            <button class="sub-tab-btn" onclick="setSubTab('Other')">Other</button>
            <button class="sub-tab-btn" onclick="setSubTab('Character')">Character</button>
        </div>
        <div id="actionsList" class="actions-container"></div>
    </div>

    <div id="view-feats" class="view-section">
        <!-- Feats injected here -->
    </div>
    
    <div id="view-magic" class="view-section">
        <!-- Magic UI constructed in renderMagic() now -->
        <div class="magic-split">
            <div id="slotColumn"></div>
            <div id="spellListColumn"></div>
        </div>
    </div>

    <div id="view-items" class="view-section">
        <div class="sub-tabs">
            <button class="sub-tab-btn active" onclick="setItemSubTab('Equipment')">Equipment</button>
            <button class="sub-tab-btn" onclick="setItemSubTab('Inventory')">Inventory</button>
            <button class="sub-tab-btn" onclick="setItemSubTab('Shop')">Shop</button>
        </div>
        
        <!-- Renamed from Equipment to match functionality, now contains Weapons -->
        <div id="item-view-Equipment">
            <h3>Weapons</h3>
            <div id="listEquippedWeapons"></div>
            <h3>Unequipped</h3>
            <div id="listUnequippedWeapons"></div>
        </div>

        <!-- Renamed old Inventory View -->
        <div id="item-view-Inventory" style="display:none">
            <h3>Consumables</h3>
            <div id="listConsumables"></div>
            <h3>Backpack</h3>
            <div id="listBackpack"></div>
        </div>

        <div id="item-view-Shop" style="display:none">
            <div id="shopList"></div>
        </div>
    </div>

</div>

<div id="infoModal" class="modal" onclick="document.getElementById('infoModal').style.display='none'">
    <div class="modal-box" onclick="event.stopPropagation()">
        <h2 id="mTitle">Title</h2>
        <div style="white-space: pre-wrap; line-height: 1.5; color:#ccc;" id="mDesc">Description...</div>
        <div id="mFooter"></div>
        <button class="modal-footer-btn" onclick="document.getElementById('infoModal').style.display='none'">Close</button>
    </div>
</div>

<div id="condModal" class="modal" onclick="document.getElementById('condModal').style.display='none'">
    <div class="modal-box" onclick="event.stopPropagation()">
        <h2>Manage Conditions</h2>
        <div id="condList" style="max-height: 400px; overflow-y: auto;"></div>
        <button onclick="document.getElementById('condModal').style.display='none'" style="width:100%; padding:10px; margin-top:15px; cursor:pointer; background:var(--bg-dark); color:var(--text-light); border:1px solid #666;">Close</button>
    </div>
</div>

<div id="qtyModal" class="modal" onclick="closeQtyModal()">
    <div class="modal-box" onclick="event.stopPropagation()">
        <h2 id="qTitle">Item Name</h2>
        <div class="qty-control-box">
            <button class="qty-btn" onclick="adjustQty(-1)">&#10094;</button> 
            <span id="qValue" style="font-size:32px; font-weight:bold;">0</span>
            <button class="qty-btn" onclick="adjustQty(1)">&#10095;</button> 
        </div>
        <button onclick="restockFromModal()" style="width:100%; background:var(--accent-red); color:white; border:none; padding:10px; font-weight:bold; cursor:pointer;">RESTOCK (BUY 1)</button>
        <div style="text-align:center; margin-top:10px; color:#888;">Price: <span id="qPrice">0</span> gp</div>
    </div>
</div>

<div id="resModal" class="modal" onclick="closeResModal()">
    <div class="modal-box" onclick="event.stopPropagation()">
        <h2 id="resTitle">Manage Resource</h2>

        <div id="resBodyAC" style="display:none;">
            <div class="toggle-row">
                <span class="toggle-label">Armor Equipped</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="checkArmor" onchange="toggleEquip('Armor')">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="toggle-row">
                <span class="toggle-label">Shield Equipped</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="checkShield" onchange="toggleEquip('Shield')">
                    <span class="slider"></span>
                </label>
            </div>
            <div style="text-align:center; font-style:italic; font-size:0.8em; color:#666; margin-top:15px;">
                Toggling off uses Base AC<br>and hides shield stats.
            </div>
        </div>

        <div id="resBodyGeneric">
            <p style="text-align:center; color:#888;">Current: <span id="resCurrent" style="color:var(--text-gold); font-weight:bold;">0</span></p>
            
            <div class="qty-control-box">
                <button class="qty-btn" style="border-color:var(--accent-red); color:var(--accent-red);" onclick="modifyResource(-1)">-</button>
                <input type="number" id="resInput" class="input-resource" placeholder="0" />
                <button class="qty-btn" style="border-color:var(--accent-green); color:var(--accent-green);" onclick="modifyResource(1)">+</button>
            </div>
            
            <button class="set-btn" onclick="setResource()">Set to Value</button>
            <div style="text-align:center; font-style:italic; font-size:0.8em; color:#666; margin-top:5px;">Enter amount and choose action</div>
        </div>

        <div id="resBodyHP" style="display:none;">
            <p style="text-align:center; color:#888;">Current HP: <span id="resCurrentHP" style="color:var(--text-gold); font-weight:bold;">0</span> &nbsp; | &nbsp; Temp: <span id="resCurrentTemp" style="color:var(--accent-blue); font-weight:bold;">0</span></p>
            <div class="hp-input-row" style="flex-direction:column; align-items:center;">
                <label for="hpInput" style="margin-bottom:-6px; align-self:center;">Hit Points</label>
                <div class="qty-control-box" style="margin:8px 0; width:100%; justify-content:center; gap:6px;">
                    <button class="qty-btn" onclick="modifyHP('HP_Current', -1)">-</button>
                    <input type="number" id="hpInput" min="0" style="width:120px;" placeholder="0" />
                    <button class="qty-btn" onclick="modifyHP('HP_Current', 1)">+</button>
                </div>
                <button class="set-btn" onclick="setHPValue('HP_Current')">Set HP to Value</button>
            </div>

            <div class="hp-input-row" style="margin-top:12px; flex-direction:column; align-items:center;">
                <label for="tempInput" style="margin-bottom:-6px; align-self:center;">Temp HP</label>
                <div class="qty-control-box" style="margin:8px 0; width:100%; justify-content:center; gap:6px;">
                    <button class="qty-btn" onclick="modifyHP('HP_Temp', -1)">-</button>
                    <input type="number" id="tempInput" min="0" style="width:120px;" placeholder="0" />
                    <button class="qty-btn" onclick="modifyHP('HP_Temp', 1)">+</button>
                </div>
                <button class="set-btn" onclick="setHPValue('HP_Temp')">Set Temp to Value</button>
            </div>

            <div style="text-align:center; font-style:italic; font-size:0.8em; color:#666; margin-top:5px;">Enter amount, then choose add/subtract or set</div>
        </div>
    </div>
</div>

<!-- CHAR MODAL -->
<div id="charModal" class="modal" onclick="document.getElementById('charModal').style.display='none'">
    <div class="modal-box" onclick="event.stopPropagation()">
        <h2>Select Character</h2>
        <div id="charList" style="margin-top:10px;"></div>
        <button onclick="document.getElementById('charModal').style.display='none'" style="width:100%; padding:10px; margin-top:15px; cursor:pointer; background:var(--bg-dark); color:var(--text-light); border:1px solid #666;">Close</button>
    </div>
</div>

<script>
    // ---------------------------------------------------------
    // 1. CONFIGURATION
    // ---------------------------------------------------------
    const API_URL = "https://script.google.com/macros/s/AKfycbxhYVYxNecn8KMSz5bz4KJ5hP8N18umOnLPcP-yKy2Kve3NN4orUkxmP6g4pbBrRu8B/exec";

    const STAT_MAP = {
        "Fortitude": "Constitution", "Reflex": "Dexterity", "Will": "Wisdom", "Perception": "Wisdom",
        "Acrobatics": "Dexterity", "Arcana": "Intelligence", "Athletics": "Strength", "Crafting": "Intelligence",
        "Deception": "Charisma", "Diplomacy": "Charisma", "Intimidate": "Charisma", "Medicine": "Wisdom",
        "Nature": "Wisdom", "Occultism": "Intelligence", "Perform": "Charisma", "Religion": "Wisdom",
        "Society": "Intelligence", "Stealth": "Dexterity", "Survival": "Wisdom", "Thievery": "Dexterity"
    };
    
    // Defines which attribute is used for attack rolls per weapon group
    const WEAPON_STAT_MAP = {
        "Firearm": "Dexterity",
        "Firearms": "Dexterity",
        "Crossbow": "Dexterity",
        "Crossbows": "Dexterity",
        "Bomb": "Dexterity",
        "Bombs": "Dexterity",
        "Sword": "Strength",
        "Swords": "Strength",
        "Default": "Strength" // Fallback
    };

    const PROF_NAMES = { 0: "Untrained", 2: "Trained", 4: "Expert", 6: "Master", 8: "Legendary" };
    
    // Conditions with binary behavior (Level 1 Max, Hidden number)
    const BINARY_CONDS = [
        "Blinded", "Concealed", "Confused", "Controlled", "Dazzled", "Deafened", 
        "Encumbered", "Fascinated", "Fleeing", "Grabbed", "Hidden", "Immobilized", "Invisible", 
        "Observed", "Off-Guard", "Paralyzed", "Petrified", "Prone", "Quickened", "Restrained", 
        "Stunned", "Unconscious", "Undetected", "Unnoticed"
    ].map(s => s.toLowerCase());

    const NEG_CONDS = [
        "blinded","clumsy","confused","controlled","dazzled","deafened","doomed","drained","dying","encumbered","enfeebled",
        "fascinated","fatigued","fleeing","frightened","grabbed","immobilized","off-guard","paralyzed","persistent damage",
        "petrified","prone","restrained","sickened","slowed","stunned","stupefied","unconscious","wounded"
    ];
    const POS_CONDS = ["quickened","blessed","fast healing"];
    const VIS_CONDS = ["concealed","hidden","invisible","observed","undetected","unnoticed"];
    
    const ICON_BASE = "https://game-icons.net/icons/ffffff/000000/1x1/";
    const ICON_MAP = {
        "blinded": "delapouite/blindfold.svg", "clumsy": "lorc/boot-stomp.svg", "concealed": "lorc/fog.svg",
        "confused": "lorc/player-despair.svg", "controlled": "lorc/puppet.svg", "dazzled": "lorc/star-swirl.svg",
        "deafened": "lorc/mute.svg", "doomed": "lorc/skull-crossed-bones.svg", "drained": "lorc/bleeding-heart.svg",
        "dying": "lorc/dead-head.svg", "encumbered": "lorc/weight.svg", "enfeebled": "lorc/muscle-down.svg",
        "fascinated": "lorc/hypnotic-eyes.svg", "fatigued": "lorc/despair.svg", "fleeing": "lorc/run.svg",
        "frightened": "lorc/screaming.svg", "grabbed": "lorc/hand-grip.svg", "hidden": "lorc/ninja-mask.svg",
        "immobilized": "lorc/net.svg", "invisible": "lorc/invisible.svg", "observed": "delapouite/eye-shield.svg",
        "off-guard": "delapouite/eye-shield.svg", "paralyzed": "lorc/electric.svg", "persistent damage": "lorc/burning-dot.svg",
        "petrified": "lorc/stone-bust.svg", "prone": "lorc/falling.svg", "quickened": "lorc/sprint.svg",
        "blessed": "delapouite/holy-grail.svg", "fast healing": "delapouite/heart-shield.svg", "restrained": "lorc/manacles.svg",
        "sickened": "lorc/vomiting.svg", "slowed": "lorc/snail.svg", "stunned": "lorc/knockout.svg",
        "stupefied": "lorc/dunce-cap.svg", "unconscious": "lorc/coma.svg", "wounded": "lorc/bleeding-wound.svg",
        "default": "lorc/aura.svg"
    };

    // --- ICON SVGs ---
    // Minimal geometric SVGs that look like the PF2e action icons
    const ACTION_ICONS = {
        // One Action (Diamond)
        "\\[one-action\\]": `<svg class="pf-icon" viewBox="0 0 100 100"><path d="M50 5 L95 50 L50 95 L5 50 Z" /></svg>`,
        // Two Actions (Two Diamonds)
        "\\[two-actions\\]": `<svg class="pf-icon" viewBox="0 0 200 100" style="width:2.2em"><path d="M50 5 L95 50 L50 95 L5 50 Z" /><path d="M150 5 L195 50 L150 95 L105 50 Z" /></svg>`,
        // Three Actions (Three Diamonds)
        "\\[three-actions\\]": `<svg class="pf-icon" viewBox="0 0 300 100" style="width:3.3em"><path d="M50 5 L95 50 L50 95 L5 50 Z" /><path d="M150 5 L195 50 L150 95 L105 50 Z" /><path d="M250 5 L295 50 L250 95 L205 50 Z" /></svg>`,
        // Free Action (Hollow Diamond)
        "\\[free-action\\]": `<svg class="pf-icon" viewBox="0 0 100 100"><path d="M50 5 L95 50 L50 95 L5 50 Z" fill="none" stroke="currentColor" stroke-width="12" /></svg>`,
        // Reaction (Curved Arrow)
        "\\[reaction\\]": `<svg class="pf-icon" viewBox="0 0 100 100"><path d="M50 15 A 35 35 0 1 0 85 50 L 70 50 L 85 30 L 100 50 L 85 50 A 35 35 0 1 1 50 15" /></svg>`
    };

    function formatText(text) {
        if (!text) return "";
        // Replace custom tags regex
        let formatted = text;
        Object.entries(ACTION_ICONS).forEach(([key, svg]) => {
             // Create regex with global and ignore case flags
             const regex = new RegExp(key, "gi");
             formatted = formatted.replace(regex, svg);
        });
        
        // formatting for gold text
        formatted = formatted.replace(/\[gold\](.*?)\[\/gold\]/gi, '<span style="color:var(--text-gold)">$1</span>');

        return formatted;
    }
    
    // Helper to escape strings for HTML attributes (fixes single quote issues)
    function esc(str) {
        if (!str) return "";
        return str.replace(/'/g, "\\'").replace(/"/g, '&quot;');
    }

    // Helper to find case-insensitive key value from an object
    // UPDATED: Now trims keys to handle accidental trailing spaces in headers (e.g., "Feat ")
    function getDBValue(obj, targetKey) {
        if (!obj || typeof obj !== 'object') return null;
        const key = Object.keys(obj).find(k => k.trim().toLowerCase() === targetKey.toLowerCase());
        return key ? obj[key] : null;
    }
    
    // NEW HELPER: Robust List Parser
    // Handles JSON arrays, comma-separated strings, or single items
    function parseList(input) {
        if (input === undefined || input === null) return [];
        if (Array.isArray(input)) return input;
        
        // Handle numbers or booleans -> Treat as single item string
        if (typeof input !== 'string') return [String(input)];

        const trimmed = input.trim();
        if (trimmed === "") return [];

        // 1. Try JSON Parse
        try {
            const parsed = JSON.parse(trimmed);
            if (Array.isArray(parsed)) return parsed;
        } catch(e) {
            // Not valid JSON, continue to next method
        }

        // 2. Try Comma Separation
        if (trimmed.includes(',')) {
            return trimmed.split(',').map(s => s.trim()).filter(s => s !== "");
        }

        // 3. Fallback: Single Item
        return [trimmed];
    }

    let state = { char: {}, db: {} };
    let currentEditItem = "";
    let currentResType = ""; 
    let currentActionSubTab = "Combat"; // Default
    let currentItemSubTab = "Equipment";

    async function init() {
            try {
                const res = await fetch(API_URL);
                const rawText = await res.text();
                try { state = JSON.parse(rawText); } 
                catch (e) { try { state = new Function("return " + rawText)(); } catch (e2) { throw e2; } }

                // --- MULTI-CHAR HANDLING ---
                if (state.characters && Array.isArray(state.characters) && state.characters.length > 0) {
                    state.allChars = state.characters;
                    state.character = state.allChars[0];
                    state.charIdx = 0;
                } else {
                    // Legacy mode: single character
                    state.allChars = [state.character];
                    state.charIdx = 0;
                }

                initCharData();

                if (state.db) {
                    // Robust lookup for 'actions' table
                    const actKey = Object.keys(state.db).find(k => k.toLowerCase().trim() === 'actions' || k.toLowerCase().includes('action'));
                    if (actKey) state.db.actions = state.db[actKey]; else state.db.actions = {};

                    // Map other tables flexibly
                    const mapTable = (target, search) => {
                         const k = Object.keys(state.db).find(k => k.toLowerCase().trim() === search);
                         state.db[target] = k ? state.db[k] : {};
                    };
                    mapTable('weapons', 'weapons');
                    mapTable('equipment', 'equipment');
                    mapTable('consumables', 'consumables');
                    mapTable('runes', 'runes');

                    if (state.db.conditions) {
                        const lowerMap = {};
                        Object.entries(state.db.conditions).forEach(([k, v]) => { lowerMap[k.toLowerCase()] = v; });
                        state.db._conditionsByLower = lowerMap;
                    }
                    
                    if (state.db.feats) {
                        const featLower = {};
                        Object.entries(state.db.feats).forEach(([k, v]) => { featLower[k.toLowerCase()] = v; });
                        state.db._featsByLower = featLower;
                    }

                    if (state.db.spells) {
                        const spellMap = {};
                        Object.entries(state.db.spells).forEach(([k,v]) => { spellMap[k.toLowerCase()] = v; });
                        state.db._spellsByLower = spellMap;
                    }
                }
                
                render();
                renderActions();
                attachActionSwipe(); 

                document.getElementById('loading').style.display = 'none';
                document.getElementById('app').style.display = 'block';
            } catch(e) { console.error(e); }
        }

    function initCharData() {
        // Run checks on CURRENT character to ensure arrays/objects exist
        const c = state.character;
        
        // --- ROBUST CONDITION PARSING ---
        if (!c.Conditions) {
            c.Conditions = [];
        } else if (typeof c.Conditions === 'string') {
            const rawCond = c.Conditions.trim();
            if (rawCond === "") c.Conditions = [];
            else {
                try { c.Conditions = JSON.parse(rawCond); } catch (e) {
                    try { c.Conditions = new Function("return " + rawCond)(); } 
                    catch (e2) { c.Conditions = []; }
                }
            }
        }
        
        // --- ROBUST SPELL SLOT PARSING ---
        if (typeof c.Spellslots === 'string') {
            try { c.Spellslots = JSON.parse(c.Spellslots); }
            catch(e) { c.Spellslots = {}; }
        }

        // Initialize default equipment states if missing
        if (state.character.Inventory_Weapons === undefined) state.character.Inventory_Weapons = [];

        // --- TOGGLES DEFAULTS ---
        if (c.Armor_Equipped === undefined) c.Armor_Equipped = true;
        if (c.Shield_Equipped === undefined) c.Shield_Equipped = true;
    }

    // Switch Character
    function openCharModal() {
        const list = document.getElementById('charList');
        list.innerHTML = "";
        state.allChars.forEach((c, idx) => {
            const div = document.createElement('div');
            div.className = "char-item-row " + (state.charIdx === idx ? "char-item-active" : "");
            div.innerHTML = `<span>${c.Name}</span> <span>Lvl ${c.Level}</span>`;
            div.onclick = () => switchCharacter(idx);
            list.appendChild(div);
        });
        document.getElementById('charModal').style.display = 'flex';
    }

    function switchCharacter(idx) {
        state.charIdx = idx;
        state.character = state.allChars[idx];
        initCharData(); // Ensure parsing for new char
        document.getElementById('charModal').style.display = 'none';
        
        // Reset tabs logic for caster
        const isCaster = state.character.Is_Caster === true;
        const magicBtn = document.getElementById('btnMagic');
        if (!isCaster) {
            magicBtn.style.display = 'none';
            // If we were on magic tab, go to main
            if(document.getElementById('view-magic').classList.contains('active')) setTab('main');
        } else {
            magicBtn.style.display = 'block';
        }
        
        render();
        renderActions(); // Re-render actions for new char feats
    }

    // --- WEAPON & ATTACK CALCULATION ---
    function calculateAttackBonus(weaponName, weaponData, instanceData) {
        const char = state.character;
        let total = 0;
        let breakdown = [];

        // 1. Attribute Modifier
        const profStr = getDBValue(weaponData, 'proficiency') || "";
        const profTags = profStr.split(',').map(s => s.trim());
        
        // Find main stat based on weapon type/group
        let attrName = "Strength"; // Default
        
        // Check against known groups in WEAPON_STAT_MAP
        for (let tag of profTags) {
            let cleanTag = tag.replace(/s$/, ''); // Bomb -> Bomb
            if (WEAPON_STAT_MAP[tag]) { attrName = WEAPON_STAT_MAP[tag]; break; }
            if (WEAPON_STAT_MAP[cleanTag]) { attrName = WEAPON_STAT_MAP[cleanTag]; break; }
        }
        
        const attrVal = parseInt(char[attrName]) || 0;
        total += attrVal;
        breakdown.push(`${attrName.substr(0,3)}: ${attrVal}`);

        // 2. Proficiency Bonus
        let bestProf = 0;
        let charProfs = char.Proficiencies || [];
        if (typeof charProfs === 'string') try { charProfs = JSON.parse(charProfs); } catch(e){ charProfs=[]; }

        profTags.forEach(tag => {
            const found = charProfs.find(p => p.name.toLowerCase() === tag.toLowerCase());
            if (found && found.prof > bestProf) bestProf = found.prof;
        });

        const level = parseInt(char.Level) || 1;
        const profBonus = (bestProf > 0) ? (bestProf + level) : 0;
        total += profBonus;
        breakdown.push(`Prof: ${profBonus}`);

        // 3. Item Bonus (Runes)
        let runeBonus = 0;
        if (instanceData && instanceData.runes) {
            instanceData.runes.forEach(r => {
                if (r === "prof_1") runeBonus += 1;
                else if (r === "prof_2") runeBonus += 2; // Future proofing
                else if (r === "prof_3") runeBonus += 3;
            });
        }
        if (runeBonus > 0) {
            total += runeBonus;
            breakdown.push(`Item: ${runeBonus}`);
        }

        return { total, breakdown: breakdown.join(', ') };
    }

    function getConditionEffects(statName, attributeName) {
        const conds = state.character.Conditions || [];
        const active = {};
        conds.forEach(c => { if(c.level > 0) active[c.name.toLowerCase()] = c.level; });
        const has = (key) => !!active[key];
        const val = (key) => active[key] || 0;
        let statusPenalties = [];

        if (has("frightened")) statusPenalties.push(-val("frightened"));
        if (has("sickened")) statusPenalties.push(-val("sickened"));

        if (attributeName === "Strength") { if (has("enfeebled")) statusPenalties.push(-val("enfeebled")); }
        else if (attributeName === "Dexterity") { if (has("clumsy")) statusPenalties.push(-val("clumsy")); if (has("encumbered")) statusPenalties.push(-1); }
        else if (attributeName === "Constitution") { if (has("drained")) statusPenalties.push(-val("drained")); }
        else if (["Intelligence", "Wisdom", "Charisma"].includes(attributeName)) { if (has("stupefied")) statusPenalties.push(-val("stupefied")); }

        if (statName === "AC" || statName === "Fortitude" || statName === "Reflex" || statName === "Will") { if (has("fatigued")) statusPenalties.push(-1); }
        if (statName === "Perception") { if (has("blinded")) statusPenalties.push(-4); if (has("deafened")) statusPenalties.push(-2); if (has("unconscious")) statusPenalties.push(-4); }

        let circPenalties = [];
        if (statName === "AC") { if (has("off-guard") || has("blinded") || has("grabbed") || has("paralyzed") || has("prone") || has("restrained") || has("unconscious")) circPenalties.push(-2); }

        const bestStatus = statusPenalties.length ? Math.min(...statusPenalties) : 0; 
        const bestCirc = circPenalties.length ? Math.min(...circPenalties) : 0;
        return { total: bestStatus + bestCirc, breakdown: (bestStatus ? `Status Penalty: ${bestStatus}\n` : "") + (bestCirc ? `Circumstance Penalty: ${bestCirc}\n` : "") };
    }

    function calculateStat(statName, profValue) {
        const char = state.character;
        const level = parseInt(char.Level) || 1;
        const prof = parseInt(profValue) || 0;
        let attrKey = "Intelligence"; 
        if (!statName.startsWith("Lore")) attrKey = STAT_MAP[statName] || "Strength";
        if (statName === "AC") attrKey = "Dexterity";
        const attrVal = parseInt(char[attrKey]) || 0;
        let total = (prof > 0) ? prof + level + attrVal : attrVal;
        const cond = getConditionEffects(statName, attrKey);
        total += cond.total;
        const breakdown = (prof > 0) ? `${prof} (${PROF_NAMES[prof]})\n+ ${level} (Lvl)\n+ ${attrVal} (${attrKey.substr(0,3)})` : `0 (Untrained)\n+ ${attrVal} (${attrKey.substr(0,3)})`;
        return { total, breakdown: breakdown + (cond.total !== 0 ? `\n\nConditions:\n${cond.breakdown}` : ""), rank: PROF_NAMES[prof] || "Unknown", penalty: cond.total };
    }

    function render() {
        const c = state.character;
        setText('uiName', c.Name);
        setText('uiLevel', c.Level);
        setText('uiXP', `${c.XP_Current} / ${c.XP_Max}`);
        // UPDATED: Gold to 2 decimal places
        setText('uiGold', parseFloat(c.Gold).toFixed(2)); 
        setText('uiSpeed', c.Speed || 25);
        setText('uiClassDC', c.Class_DC || 10);
        
        const conds = state.character.Conditions || [];
        const drained = conds.find(x => x.name.toLowerCase() === "drained");
        const drainedVal = (drained && drained.level > 0) ? drained.level : 0;
        const hpPenalty = drainedVal * (parseInt(c.Level) || 1);
        
        const hp = parseInt(c.HP_Current) || 0;
        let maxHp = parseInt(c.HP_Max) || 1;
        if (hpPenalty > 0) maxHp = Math.max(1, maxHp - hpPenalty);

        setText('uiHP', hp);
        setText('uiMaxHP', maxHp);
        const pct = Math.max(0, Math.min(100, (hp / maxHp) * 100));
        let barColor = '#4caf50'; 
        if (pct < 25) barColor = '#d32f2f'; else if (pct < 50) barColor = '#f57c00'; else if (pct < 75) barColor = '#fbc02d'; else if (pct < 90) barColor = '#8bc34a';
        document.getElementById('hpBarFill').style.width = pct + "%";
        document.getElementById('hpBarFill').style.backgroundColor = barColor;

        const tempHp = parseInt(c.HP_Temp) || 0;
        setText('uiTempHP', tempHp);
        const tBar = document.getElementById('barTempHP');
        const tFill = tBar.querySelector('.temp-bar-fill');
        if (tempHp > 0) { tBar.style.display = 'block'; const tempPct = Math.min(100, (tempHp / maxHp) * 100); tFill.style.width = tempPct + "%"; tBar.style.opacity = 1; } 
        else { tBar.style.display = 'none'; }
        refreshHPModalFields();

        ['Strength','Dexterity','Constitution','Intelligence','Wisdom','Charisma'].forEach(k => {
            const val = parseInt(c[k]) || 0;
            const sign = val >= 0 ? "+" : "";
            setText('ui'+k.substr(0,3), sign + val);
        });

        const savesContainer = document.getElementById('savesGrid');
        savesContainer.innerHTML = "";
        
        const isArmorOn = c.Armor_Equipped !== false;
        const isShieldOn = c.Shield_Equipped !== false;
        const sDef = parseInt(c.Shield_Defense) || 0;
        const sHard = parseInt(c.Shield_Hardness) || 0;
        const sHp = parseInt(c.HP_Shield_Current) || 0;
        const sMax = parseInt(c.HP_Shield_Max) || 0;
        const hasShield = (sDef > 0 || sHard > 0 || sMax > 0) && isShieldOn;
        const isBroken = (sHp <= (sMax / 2)) && hasShield;
        
        let baseAC = isArmorOn ? (c.Armor || 10) : (c.Base_AC || 10);
        const acCond = getConditionEffects("AC", "Dexterity");
        const acFinal = baseAC + acCond.total;
        
        const acPenaltyHtml = acCond.total < 0 ? `<div class="stat-penalty-sub">(${acCond.total})</div>` : "";
        const acValClass = acCond.total < 0 ? "stat-penalty" : "";
        
        let acHtml = `<div class="stat-box shield-box" onclick="openResourceModal('AC')"><div class="stat-val ${acValClass}">${acFinal}</div>${acPenaltyHtml}<div class="stat-label shield-label">AC</div>${hasShield ? `<div class="shield-bonus-badge ${isBroken?'broken-stat':''}">+${sDef}</div>` : ''}</div>`;
        savesContainer.innerHTML += acHtml;

        const saveMap = {"Fortitude": "Fortitude", "Reflex": "Reflex", "Will": "Willpower"};
        Object.keys(saveMap).forEach(key => {
            const raw = c[key] || 0;
            const calc = calculateStat(key, raw);
            const sign = calc.total >= 0 ? "+" : "";
            const penaltyHtml = calc.penalty < 0 ? `<div class="stat-penalty-sub">(${calc.penalty})</div>` : "";
            const valClass = calc.penalty < 0 ? "stat-penalty" : "";
            
            const div = document.createElement('div');
            div.className = "stat-box"; div.style.cursor="pointer";
            div.onclick = () => showInfoModal(key, `Total: ${sign}${calc.total}\nRank: ${calc.rank}\n\n${calc.breakdown}`);
            div.innerHTML = `<div class="stat-val ${valClass}">${sign}${calc.total}</div>${penaltyHtml}<div class="stat-label">${saveMap[key]}</div>`;
            savesContainer.appendChild(div);
        });

        const shieldArea = document.getElementById('shieldStatusArea');
        shieldArea.innerHTML = "";
        if (hasShield) {
            const sPct = Math.max(0, Math.min(100, (sHp / sMax) * 100));
            const statusText = isBroken ? `<span style="color:var(--accent-red); margin-left:5px;">(Broken!)</span>` : "";
            const brokenClass = isBroken ? "broken-stat" : "";
            shieldArea.innerHTML = `<div class="shield-status-row" onclick="openResourceModal('Shield')"><div class="shield-text ${brokenClass}">Hardness: ${sHard}</div><div class="shield-hp-bar"><div class="shield-fill" style="width:${sPct}%;"></div><div class="shield-break-marker"></div></div><div class="shield-text">${sHp}/${sMax}${statusText}</div></div>`;
        }

        renderConditions();
        renderFeats();
        renderWeapons(); // New weapon render

        // --- MAGIC RENDER ---
        if (c.Is_Caster === true) {
            document.getElementById('btnMagic').style.display = 'block';
            renderMagic();
        } else {
            document.getElementById('btnMagic').style.display = 'none';
        }

        const perRaw = c.Perception || 0;
        const perCalc = calculateStat("Perception", perRaw);
        const perSign = perCalc.total >= 0 ? "+" : "";
        const perValClass = perCalc.penalty < 0 ? "stat-penalty" : "";
        setText("uiPer", perSign + perCalc.total);
        document.getElementById('uiPer').className = "stat-val " + perValClass;
        document.getElementById('uiPerBox').onclick = () => showInfoModal("Perception", `Total: ${perCalc.total}\nRank: ${perCalc.rank}\n\n${perCalc.breakdown}`);

        renderListArray(c.Senses, 'uiSenses');
        renderListArray(c.Languages, 'uiLanguages', 'LANGUAGES');

        const skillContainer = document.getElementById('skillsList');
        skillContainer.innerHTML = "";
        let keys = Object.keys(STAT_MAP).filter(k=>!["Fortitude","Reflex","Will","Perception"].includes(k));
        Object.keys(c).forEach(k => { if(k.startsWith("Lore")) keys.push(k); });
        keys.sort().forEach(key => {
            const raw = c[key] || 0;
            if (key.startsWith("Lore") && raw === 0) return;
            const calc = calculateStat(key, raw);
            const isTrained = raw > 0;
            const row = document.createElement('div');
            row.className = 'item-row';
            row.onclick = () => showInfoModal(key, `Total: ${calc.total}\nRank: ${calc.rank}\n\n${calc.breakdown}`);
            let valClass = isTrained ? "skill-trained" : "skill-untrained";
            let nameColor = isTrained ? "var(--text-gold)" : "#ccc";
            let nameText = key.replace('_',' ');
            if (calc.penalty < 0) { valClass = "stat-penalty"; nameText += ` <span style="font-size:0.8em; color:#ef5350;">(${calc.penalty})</span>`; }
            row.innerHTML = `<span class="item-name" style="color:${nameColor}">${nameText}</span><span class="skill-val ${valClass}">${calc.total>=0?'+':''}${calc.total}</span>`;
            skillContainer.appendChild(row);
        });

        renderList('listConsumables', c.Inventory_Consumables);
        renderList('listBackpack', c.Inventory_Gear_Backpack);
    }

    // --- WEAPON RENDERING ---
    function renderWeapons() {
        const equippedEl = document.getElementById('listEquippedWeapons');
        const unequippedEl = document.getElementById('listUnequippedWeapons');
        equippedEl.innerHTML = "";
        unequippedEl.innerHTML = "";

        // Get Character Weapons Array
        let weapons = parseList(state.character.Inventory_Weapons);
        
        if (weapons.length === 0) {
            equippedEl.innerHTML = "<div style='color:#666;font-style:italic;'>No weapons found.</div>";
            return;
        }

        weapons.forEach((inst, index) => {
            // Lookup static data
            const staticData = state.db.weapons[inst.name];
            if (!staticData) {
                const fallback = document.createElement('div');
                fallback.innerText = `${inst.name} (Data missing)`;
                unequippedEl.appendChild(fallback);
                return;
            }

            // Calculation
            const hitCalc = calculateAttackBonus(inst.name, staticData, inst);
            const sign = hitCalc.total >= 0 ? "+" : "";
            
            // Ammo Logic
            let ammoText = "âˆž"; // Default unlimited
            const consumes = getDBValue(staticData, "consumes");
            const isGun = inst.barrels !== undefined;
            const consumablesList = parseList(state.character.Inventory_Consumables);
            let reserveAmmo = 0;

            if (consumes) {
                // For guns or standard ammo weapons, find reserve count
                if (consumes.toLowerCase() === inst.name.toLowerCase()) {
                    // Bomb Logic (Weapon consumes itself)
                    const ammoItem = consumablesList.find(i => i.name && i.name.toLowerCase() === consumes.toLowerCase());
                    reserveAmmo = ammoItem ? (parseInt(ammoItem.qty) || 0) : 0;
                    ammoText = reserveAmmo;
                } else {
                    // Standard ammo (Arrows/Bolts/Bullets)
                    const ammoItem = consumablesList.find(i => i.name && i.name.toLowerCase() === consumes.toLowerCase());
                    reserveAmmo = ammoItem ? (parseInt(ammoItem.qty) || 0) : 0;
                    ammoText = `${consumes}: ${reserveAmmo}`;
                }
            } else if (isGun) {
                 ammoText = "No Ammo Defined";
            }

            const damage = getDBValue(staticData, "damage") || "1d4";
            
            // Barrel UI Construction
            let barrelHtml = "";
            if (isGun && inst.barrels > 0) {
                barrelHtml = `<div class="barrel-container" onclick="event.stopPropagation()">`;
                const loadedCount = parseInt(inst.barrels_loaded) || 0;
                for(let i=1; i<=inst.barrels; i++) {
                     const isLoaded = i <= loadedCount;
                     // Pass consumable name to function to handle deduction
                     barrelHtml += `<div class="barrel-opt ${isLoaded?'loaded':''}" onclick="toggleBarrel(${index}, ${loadedCount}, ${inst.barrels}, '${esc(consumes)}', ${reserveAmmo}, ${isLoaded})"></div>`;
                }
                barrelHtml += `</div>`;
            }

            // HTML Construction
            const div = document.createElement('div');
            div.className = 'weapon-entry';
            div.onclick = () => showWeaponModal(inst, staticData, index, hitCalc);

            div.innerHTML = `
                <div class="weapon-top">
                    <span class="item-name">${inst.name}</span>
                    ${barrelHtml}
                    <span class="w-bonus">${sign}${hitCalc.total}</span>
                </div>
                <div class="weapon-bot">
                    <span class="w-damage">${damage}</span>
                    <span class="w-ammo">${ammoText}</span>
                </div>
            `;

            if (inst.equipped == 1) equippedEl.appendChild(div);
            else unequippedEl.appendChild(div);
        });
    }

    async function toggleBarrel(index, currentLoaded, maxBarrels, ammoName, reserveAmmo, isLoaded) {
        // Prevent event bubbling handled by HTML onclick, but double check logic
        let weapons = parseList(state.character.Inventory_Weapons);
        let consumables = parseList(state.character.Inventory_Consumables);
        
        if (!weapons[index]) return;

        let newLoaded = currentLoaded;
        let ammoChange = 0;

        if (isLoaded) {
            // UNCHECKING (Firing): Reduce loaded count (consumes loaded bullet)
            // No reserve change, bullet was already deducted on load
            if (newLoaded > 0) newLoaded--;
        } else {
            // CHECKING (Reloading): Increase loaded count, Deduct from Reserve
            if (newLoaded < maxBarrels) {
                if (reserveAmmo > 0) {
                    newLoaded++;
                    ammoChange = -1;
                } else {
                    return; // Cannot reload
                }
            }
        }
        
        // Update State locally
        weapons[index].barrels_loaded = newLoaded;
        state.character.Inventory_Weapons = weapons;

        if (ammoChange !== 0) {
             let item = consumables.find(i => i.name && i.name.toLowerCase() === ammoName.toLowerCase());
             if (item) {
                 item.qty = (parseInt(item.qty) || 0) + ammoChange;
                 state.character.Inventory_Consumables = consumables;
             }
             // Ensure ammo deduction is synced even if update_gun_state doesn't handle it
             post({action: "adjust_qty", itemName: ammoName, delta: ammoChange});
        }

        render();
        
        // Sync Gun State
        await post({
            action: "update_gun_state", 
            weaponIndex: index, 
            barrelsLoaded: newLoaded,
            ammoName: ammoName,
            ammoChange: ammoChange
        });
    }

    function showWeaponModal(inst, staticData, index, hitCalc) {
        const title = inst.name;
        const desc = getDBValue(staticData, 'description') || "No description.";
        const crit = getDBValue(staticData, 'critdamage') || "2x Damage";
        const range = getDBValue(staticData, 'range') || "Melee";
        const special = getDBValue(staticData, 'special') || "-";
        
        let body = `
            <div style="color:var(--text-gold); font-size:1.1em; margin-bottom:10px;">Attack Bonus: ${hitCalc.total >= 0 ? '+' : ''}${hitCalc.total}</div>
            <div style="font-size:0.9em; color:#888; margin-bottom:10px;">Calc: ${hitCalc.breakdown}</div>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:15px; background:rgba(255,255,255,0.05); padding:10px; border-radius:4px;">
                <div><strong>Range:</strong> ${range}</div>
                <div><strong>Crit:</strong> ${crit}</div>
            </div>
            <div style="margin-bottom:10px;">${formatText(desc)}</div>
            ${special !== "-" ? `<div style="font-size:0.9em; color:#aaa; margin-top:5px;"><em>Special: ${special}</em></div>` : ''}
        `;

        document.getElementById('mTitle').innerText = title;
        document.getElementById('mDesc').innerHTML = body;
        
        // Footer Button (Equip/Unequip)
        const btn = document.createElement('button');
        btn.className = "modal-equip-btn";
        const isEquipped = inst.equipped == 1;
        btn.innerText = isEquipped ? "UNEQUIP" : "EQUIP";
        btn.style.backgroundColor = isEquipped ? "#444" : "var(--text-gold)";
        btn.style.color = isEquipped ? "#ccc" : "var(--bg-dark)";
        btn.onclick = () => toggleWeaponEquip(index);
        
        const footer = document.getElementById('mFooter');
        footer.innerHTML = "";
        footer.appendChild(btn);

        document.getElementById('infoModal').style.display = 'flex';
    }

    async function toggleWeaponEquip(index) {
        let weapons = parseList(state.character.Inventory_Weapons);
        if (weapons[index]) {
            weapons[index].equipped = weapons[index].equipped == 1 ? 0 : 1;
            state.character.Inventory_Weapons = weapons;
            render(); // Re-render lists
            document.getElementById('infoModal').style.display = 'none';
            await post({action: "update_weapon_status", index: index, equipped: weapons[index].equipped});
        }
    }

    // --- GENERIC ACTIONS ---

    function setSubTab(tabName) {
        currentActionSubTab = tabName;
        renderActions();
    }

    function renderActions() {
        const listEl = document.getElementById('actionsList');
        listEl.innerHTML = "";
        document.querySelectorAll('#view-actions .sub-tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.textContent.trim() === currentActionSubTab);
        });

        const actionsDB = state.db.actions || {};
        const entries = Object.entries(actionsDB);
        
        let hasItems = false;
        const charFeats = parseList(state.character.Feats);
        const charFeatSet = new Set(charFeats.map(f => String(f).toLowerCase().trim()));

        entries.forEach(([name, data]) => {
            const requiredFeat = getDBValue(data, 'feat') || getDBValue(data, 'feats') || getDBValue(data, 'prerequisite') || getDBValue(data, 'prerequisites');
            if (requiredFeat && requiredFeat.trim() !== "") {
                if (!charFeatSet.has(requiredFeat.toLowerCase().trim())) return;
            }

            let typeStr = getDBValue(data, 'type') || "Other";
            const types = typeStr.split(',').map(t => t.trim().toLowerCase());
            if (!types.includes(currentActionSubTab.toLowerCase())) return;
            
            hasItems = true;

            if (name.startsWith('!')) {
                const header = document.createElement('div');
                header.className = 'action-section-header';
                header.innerText = name.substring(1); 
                listEl.appendChild(header);
                return; 
            }

            const desc = getDBValue(data, 'description') || "No description.";
            const skillNameString = getDBValue(data, 'skill');
            let rightSide = ""; 
            
            if (skillNameString && skillNameString.trim()) {
                const skillNames = skillNameString.split(',').map(s => s.trim());
                let bestCalc = null;
                skillNames.forEach(sName => {
                    let rawProf = 0;
                    const charKey = Object.keys(state.character).find(k => k.toLowerCase() === sName.toLowerCase());
                    if (charKey) rawProf = state.character[charKey];
                    const calc = calculateStat(sName, rawProf);
                    if (!bestCalc || calc.total > bestCalc.total) bestCalc = calc;
                });
                if (bestCalc) {
                    const sign = bestCalc.total >= 0 ? "+" : "";
                    rightSide = `<span class="action-bonus">${sign}${bestCalc.total}</span>`;
                }
            }

            const row = document.createElement('div');
            row.className = 'item-row';
            row.innerHTML = `<span class="item-name">${formatText(name)}</span> ${rightSide}`;
            row.onclick = () => showInfoModal(name, desc);
            listEl.appendChild(row);
        });

        if (!hasItems) listEl.innerHTML = `<div style='padding:10px; color:#aaa; font-style:italic;'>No actions available.</div>`;
    }

    function attachActionSwipe() {
        const container = document.getElementById('view-actions');
        if (!container) return;
        let startX = 0;
        container.addEventListener('touchstart', (e) => { startX = e.changedTouches[0].screenX; }, {passive: true});
        container.addEventListener('touchend', (e) => {
            const dx = e.changedTouches[0].screenX - startX;
            if (Math.abs(dx) < 50) return;
            const tabs = ["Combat", "Movement", "Skill", "Other", "Character"];
            let idx = tabs.indexOf(currentActionSubTab);
            if (dx < 0) { idx++; if (idx >= tabs.length) idx = 0; if (idx < tabs.length) setSubTab(tabs[idx]); } 
            else { idx--; if (idx < 0) idx = 0; if (idx >= 0) setSubTab(tabs[idx]); }
        }, {passive: true});
    }

    function renderFeats() {
        const container = document.getElementById('view-feats');
        container.innerHTML = "";
        let rawFeats = parseList(state.character.Feats);
        if (rawFeats.length === 0) { container.innerHTML = "<div style='text-align:center;color:#666;font-style:italic;'>No feats found.</div>"; return; }

        const cats = { "Class": [], "Ancestry": [], "General": [], "Skill": [], "Other": [] };
        const dbFeats = state.db.feats || {};
        const dbFeatsLower = state.db._featsByLower || {};

        rawFeats.forEach(featName => {
            if (!featName) return;
            let featObj = dbFeats[featName] || dbFeatsLower[featName.toLowerCase()];
            let type = "Other";
            let desc = "No description available.";
            
            if (featObj) {
                const foundType = getDBValue(featObj, "type") || getDBValue(featObj, "feat type") || getDBValue(featObj, "category") || getDBValue(featObj, "trait");
                if (foundType) type = foundType;
                const foundDesc = getDBValue(featObj, "description") || getDBValue(featObj, "desc") || getDBValue(featObj, "text") || getDBValue(featObj, "effect");
                if (foundDesc) desc = foundDesc;
            }
            const tLow = String(type).toLowerCase();
            let target = "Other";
            if (tLow.includes("class")) target = "Class";
            else if (tLow.includes("ancestry")) target = "Ancestry";
            else if (tLow.includes("skill")) target = "Skill";
            else if (tLow.includes("general")) target = "General";
            cats[target].push({ name: featName, desc: desc });
        });

        const order = ["Class", "Ancestry", "General", "Skill", "Other"];
        order.forEach(key => {
            const list = cats[key];
            if (list.length > 0) {
                const h3 = document.createElement('h3');
                h3.innerText = key + " Feats";
                container.appendChild(h3);
                const listDiv = document.createElement('div');
                list.sort((a,b) => a.name.localeCompare(b.name)).forEach(f => {
                    const row = document.createElement('div');
                    row.className = 'item-row';
                    row.innerHTML = `<span class="item-name">${f.name}</span>`;
                    row.onclick = () => showInfoModal(f.name, f.desc);
                    listDiv.appendChild(row);
                });
                container.appendChild(listDiv);
                const sep = document.createElement('div');
                sep.className = 'section-separator';
                container.appendChild(sep);
            }
        });
    }

    // --- MAGIC LOGIC ---
    function renderMagic() {
        const c = state.character;
        
        // --- 1. SLOTS & STATS COLUMN (LEFT) ---
        const slotsCol = document.getElementById('slotColumn');
        slotsCol.innerHTML = "";
        
        // A. Stats Header
        // Calculate Attack: Prof + Level + Attribute
        const profVal = parseInt(c.Spell_Attack) || 0;
        const lvl = parseInt(c.Level) || 1;
        const attrName = c.Spell_Attribute || "Intelligence";
        const attrMod = parseInt(c[attrName]) || 0;
        const atkBonus = (profVal > 0) ? (profVal + lvl + attrMod) : attrMod;
        const dcVal = c.Spell_DC || 0;
        const atkStr = (atkBonus >= 0 ? "+" : "") + atkBonus;

        const statsHtml = `
        <div class="magic-stat-block">
            <!-- Spell DC Hex -->
            <div class="hex-box">
                <div class="hex-content">
                    <div class="stat-val">${dcVal}</div>
                    <div class="stat-label" style="font-size:0.6em;">SPELL DC</div>
                </div>
            </div>
            <!-- Attack -->
            <div class="spell-attack-box">
                <div class="stat-val">${atkStr}</div>
                <div class="stat-label">ATTACK</div>
            </div>
        </div>
        <div class="section-separator"></div>
        `;
        slotsCol.innerHTML = statsHtml;

        // B. Slots
        const slots = c.Spellslots || {};
        const slotKeys = ['f', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
        
        slotKeys.forEach(k => {
            const max = slots[k + "_max"];
            const curr = slots[k + "_curr"];
            if (max > 0) {
                const title = (k === 'f') ? "Focus Points" : "Level " + k;
                const box = document.createElement('div');
                box.className = "slot-box";
                
                let checksHtml = "";
                // Logic: Render 'max' boxes. The first 'curr' boxes are filled.
                for (let i = 1; i <= max; i++) {
                    const isActive = i <= curr;
                    checksHtml += `<div class="slot-check ${isActive?'active':''}" onclick="toggleSpellSlot('${k}', ${i}, ${curr})"></div>`;
                }
                
                box.innerHTML = `<div class="slot-title" style="font-size:0.6em;">${title}</div><div class="slot-checks">${checksHtml}</div>`;
                slotsCol.appendChild(box);
            }
        });

        // --- 2. SPELLS LIST COLUMN (RIGHT) ---
        const listCol = document.getElementById('spellListColumn');
        listCol.innerHTML = "";
        
        const levels = [
            { id: 'Focus', label: 'Focus Spells', source: 'Spells_Focus' },
            { id: '0', label: 'Cantrips', source: 'Spells_0' },
            { id: '1', label: 'Level 1', source: 'Spells_1' },
            { id: '2', label: 'Level 2', source: 'Spells_2' },
            { id: '3', label: 'Level 3', source: 'Spells_3' },
            { id: '4', label: 'Level 4', source: 'Spells_4' },
            { id: '5', label: 'Level 5', source: 'Spells_5' },
            { id: '6', label: 'Level 6', source: 'Spells_6' },
            { id: '7', label: 'Level 7', source: 'Spells_7' },
            { id: '8', label: 'Level 8', source: 'Spells_8' },
            { id: '9', label: 'Level 9', source: 'Spells_9' },
            { id: '10', label: 'Level 10', source: 'Spells_10' },
        ];

        levels.forEach(lvl => {
            let spellStr = c[lvl.source];
            if (!spellStr) return;
            
            // Parse list
            let spellList = [];
            try {
                if (spellStr.includes(',')) spellList = spellStr.split(',').map(s => s.trim());
                else spellList = [spellStr.trim()];
            } catch(e) { return; }
            
            if (spellList.length === 0 || spellList[0] === "") return;

            // Header
            const header = document.createElement('div');
            header.className = "spell-list-header";
            header.innerText = lvl.label;
            listCol.appendChild(header);

            spellList.forEach(sName => {
                const db = state.db.spells || {};
                const dbLower = state.db._spellsByLower || {};
                let details = db[sName] || dbLower[sName.toLowerCase()] || {};
                
                let desc = getDBValue(details, "description") || getDBValue(details, "effect") || "No description found.";
                const rawTarget = getDBValue(details, "target") || getDBValue(details, "area") || "";
                
                // Explicitly look for CastTime and Range as requested by user
                const rawTime = getDBValue(details, "CastTime") || getDBValue(details, "cast") || getDBValue(details, "time") || getDBValue(details, "actions") || getDBValue(details, "casting time") || "";
                const rawRange = getDBValue(details, "Range") || getDBValue(details, "range") || "";
                const tagsStr = getDBValue(details, "tags") || "";

                // Bloodline Logic
                const isBloodline = tagsStr.toLowerCase().includes("bloodline");
                let dropHtml = isBloodline ? `<span class="bloodline-drop">ðŸ©¸</span>` : "";

                const row = document.createElement('div');
                row.className = "spell-row";
                row.onclick = () => showSpellModal(sName, desc, isBloodline);
                
                // Format Target short
                let tgt = rawTarget ? rawTarget : "";
                if (tgt.includes("Fortitude")) tgt = "Fort";
                else if (tgt.includes("Reflex")) tgt = "Ref";
                else if (tgt.includes("Willpower")) tgt = "Will";
                else if (tgt.includes("AC")) tgt = "AC";

                const castIcons = formatText(rawTime);
                
                // Layout: Range | Target | Time
                let metaHtml = "";
                if (rawRange) metaHtml += `<span>${rawRange}</span>`;
                if (tgt) { if(metaHtml) metaHtml += ` <span style="color:#444">â€¢</span> `; metaHtml += `<span>${tgt}</span>`; }
                if (castIcons) { if(metaHtml) metaHtml += ` <span style="color:#444">â€¢</span> `; metaHtml += `<span>${castIcons}</span>`; }

                row.innerHTML = `
                    <div style="font-weight:bold; color:#ccc; display:flex; align-items:center;">${sName}${dropHtml}</div>
                    <div class="spell-meta">${metaHtml}</div>
                `;
                listCol.appendChild(row);
            });
        });
    }
    
    // Updated Modal logic for Spells to include Bloodline info
    function showSpellModal(title, desc, isBloodline) {
        let fullDesc = formatText(desc);
        
        if (isBloodline) {
            // Attempt to find Bloodline description from feats
            const featList = parseList(state.character.Feats);
            // Look for feat with "Bloodline" in title, or generically "Bloodline"
            // We search db.feats for full text
            const dbFeats = state.db.feats || {};
            const dbFeatsLower = state.db._featsByLower || {};
            
            // 1. Try to find user's specific bloodline feat
            let bloodlineFeat = featList.find(f => f.toLowerCase().includes("bloodline"));
            
            // 2. If not found, fall back to "Blood Magic" (generic effect)
            if (!bloodlineFeat) {
                // Check if user has "Blood Magic" feat explicitly or if it exists in DB
                if (dbFeats["Blood Magic"] || dbFeatsLower["blood magic"]) {
                    bloodlineFeat = "Blood Magic";
                }
            }
            
            if (bloodlineFeat) {
                let fData = dbFeats[bloodlineFeat] || dbFeatsLower[bloodlineFeat.toLowerCase()];
                // If direct lookup fails, try find by key that includes name
                if (!fData) {
                    const foundKey = Object.keys(dbFeatsLower).find(k => k.includes(bloodlineFeat.toLowerCase()));
                    if (foundKey) fData = dbFeatsLower[foundKey];
                }

                let fDesc = fData ? (getDBValue(fData, "description") || getDBValue(fData, "effect")) : null;
                
                if (fDesc) {
                    fullDesc += `<div class="section-separator" style="margin-top:20px;"></div>
                    <div style="color:var(--accent-red); font-weight:bold; margin-bottom:5px;">${bloodlineFeat}</div>
                    <div style="font-size:0.9em; color:#aaa;">${formatText(fDesc)}</div>`;
                }
            }
        }
        
        showInfoModal(title, fullDesc);
    }

    async function toggleSpellSlot(lvlKey, indexClicked, currentVal) {
        let newVal = currentVal;
        if (indexClicked === currentVal) newVal = currentVal - 1; // Toggle off top
        else newVal = indexClicked; // Set to this level
        
        state.character.Spellslots[lvlKey + "_curr"] = newVal;
        render(); // Update UI
        await post({action: "modify_spellslot", level: lvlKey, value: newVal});
    }

    function renderConditions() {
        const area = document.getElementById('conditionsArea');
        const active = state.character.Conditions.filter(c => c.level > 0).sort((a,b)=>a.name.localeCompare(b.name));
        area.innerHTML = "";
        if (active.length === 0) {
            area.innerHTML = `<button class="btn-condition-add" onclick="openConditionModal()">+ Add Condition</button>`;
            return;
        }
        active.forEach(c => {
            const iconUrl = ICON_BASE + (ICON_MAP[c.name.toLowerCase()] || ICON_MAP['default']);
            const div = document.createElement('div');
            let badgeClass = "condition-badge";
            const lower = c.name.toLowerCase();
            if (POS_CONDS.includes(lower)) badgeClass += " cond-positive";
            else if (VIS_CONDS.includes(lower)) badgeClass += " cond-visibility";
            const isBinary = BINARY_CONDS.includes(lower);
            const levelClass = isBinary ? "cond-level-hidden" : "cond-level";
            div.className = badgeClass;
            div.onclick = () => openConditionModal();
            div.innerHTML = `<img src="${iconUrl}" class="cond-icon"><span class="cond-name">${c.name}</span><span class="${levelClass}">${c.level}</span>`;
            area.appendChild(div);
        });
    }

    function openConditionModal() {
        ensureConditionCatalog();
        const hasActive = state.character.Conditions.some(c => c.level > 0);
        currentCondTab = hasActive ? "active" : "negative";
        buildConditionTabs();
        renderConditionTab();
        document.getElementById('condModal').style.display = 'flex';
        attachCondSwipe();
    }

    function showConditionInfo(name) {
        let desc = "No description available.";
        const lowerName = name.toLowerCase();
        const dbCond = state.db?.conditions || {};
        const dbCondLower = state.db?._conditionsByLower || {};
        let condObj = dbCond[name] || dbCondLower[lowerName];
        if (condObj) {
             const found = getDBValue(condObj, "description") || getDBValue(condObj, "desc") || getDBValue(condObj, "text") || getDBValue(condObj, "effect");
             if (found) desc = found;
        }
        showInfoModal(name, desc);
    }

    let currentCondTab = "negative";
    function ensureConditionCatalog() {
        const allNames = [...NEG_CONDS, ...POS_CONDS, ...VIS_CONDS];
        allNames.forEach(n => {
            if (!state.character.Conditions.find(c => c.name.toLowerCase() === n)) {
                state.character.Conditions.push({ name: n.replace(/\b\w/g, l=>l.toUpperCase()), level: 0 });
            }
        });
        state.character.Conditions = state.character.Conditions.map(c => ({ name: c.name, level: c.level || 0 }));
    }

    function getCondTabs() {
        const activeList = state.character.Conditions.filter(c => c.level > 0);
        const tabs = [{ key: "negative", label: "Negative" }, { key: "positive", label: "Positive" }, { key: "visibility", label: "Visibility" }];
        if (activeList.length > 0) tabs.unshift({ key: "active", label: "Active" });
        if (!tabs.find(t => t.key === currentCondTab)) currentCondTab = tabs[0].key;
        return tabs;
    }

    function buildConditionTabs() {
        const container = document.getElementById('condList');
        container.innerHTML = "";
        const tabs = getCondTabs();
        const tabBar = document.createElement('div');
        tabBar.className = "cond-tabs";
        tabs.forEach(t => {
            const btn = document.createElement('button');
            btn.className = `cond-tab-btn ${currentCondTab === t.key ? 'active' : ''}`;
            btn.innerText = t.label;
            btn.dataset.key = t.key;
            btn.onclick = () => setConditionTab(t.key);
            tabBar.appendChild(btn);
        });
        container.appendChild(tabBar);
        const listWrap = document.createElement('div');
        listWrap.id = "condTabList";
        container.appendChild(listWrap);
    }

    function setConditionTab(key) {
        currentCondTab = key;
        buildConditionTabs();
        renderConditionTab();
    }

    function renderConditionTab() {
        const listWrap = document.getElementById('condTabList');
        if (!listWrap) return;
        listWrap.innerHTML = "";
        const tabKey = currentCondTab;
        let conds = state.character.Conditions;
        if (tabKey === "active") conds = conds.filter(c => c.level > 0);
        else if (tabKey === "negative") conds = conds.filter(c => NEG_CONDS.includes(c.name.toLowerCase()) || (!POS_CONDS.includes(c.name.toLowerCase()) && !VIS_CONDS.includes(c.name.toLowerCase())));
        else if (tabKey === "positive") conds = conds.filter(c => POS_CONDS.includes(c.name.toLowerCase()));
        else if (tabKey === "visibility") conds = conds.filter(c => VIS_CONDS.includes(c.name.toLowerCase()));
        conds = conds.sort((a,b)=>a.name.localeCompare(b.name));
        if (tabKey === "active" && conds.length === 0) { listWrap.innerHTML = "<div style='color:#888; text-align:center; padding:10px;'>No active conditions.</div>"; return; }

        const tabs = document.querySelectorAll('.cond-tab-btn');
        tabs.forEach(btn => { btn.classList.toggle('active', btn.dataset.key === tabKey); });

        conds.forEach(c => {
            const iconUrl = ICON_BASE + (ICON_MAP[c.name.toLowerCase()] || ICON_MAP['default']);
            const lower = c.name.toLowerCase();
            const isBinary = BINARY_CONDS.includes(lower);
            const maxLevel = isBinary ? 1 : 20;

            const row = document.createElement('div');
            row.className = 'cond-modal-row';
            
            const left = document.createElement('div');
            left.className = 'cond-modal-left';
            left.onclick = () => showConditionInfo(c.name);
            left.innerHTML = `<img src="${iconUrl}" style="width:24px; filter:invert(1);"> <span>${c.name}</span>`;
            
            const right = document.createElement('div');
            right.style.display="flex"; right.style.alignItems="center";
            
            const minus = document.createElement('span');
            minus.className = `cond-chevron ${c.level <= 0 ? 'disabled' : ''}`;
            minus.innerHTML = "&#10094;";
            minus.onclick = () => modifyConditionLevel(c.name, -1, maxLevel);
            
            const val = document.createElement('span');
            val.className = "cond-val-disp";
            val.style.color = c.level > 0 ? "var(--text-gold)" : "#666";
            val.innerText = c.level;
            
            const plus = document.createElement('span');
            plus.className = `cond-chevron ${c.level >= maxLevel ? 'disabled' : ''}`;
            plus.innerHTML = "&#10095;";
            plus.onclick = () => modifyConditionLevel(c.name, 1, maxLevel);
            
            right.appendChild(minus);
            right.appendChild(val);
            right.appendChild(plus);
            row.appendChild(left);
            row.appendChild(right);
            listWrap.appendChild(row);
        });
    }

    function attachCondSwipe() {
        const modalBox = document.querySelector('#condModal .modal-box');
        if (!modalBox) return;
        let startX = 0;
        modalBox.ontouchstart = (e) => { startX = e.changedTouches[0].screenX; };
        modalBox.ontouchend = (e) => {
            const dx = e.changedTouches[0].screenX - startX;
            if (Math.abs(dx) < 40) return;
            const tabs = getCondTabs();
            let idx = tabs.findIndex(t => t.key === currentCondTab);
            if (dx < 0 && idx < tabs.length - 1) { currentCondTab = tabs[idx+1].key; }
            else if (dx > 0 && idx > 0) { currentCondTab = tabs[idx-1].key; }
            buildConditionTabs();
            renderConditionTab();
        };
    }

    async function modifyConditionLevel(name, delta, maxLevel = 20) {
        const cond = state.character.Conditions.find(c => c.name === name);
        if (!cond) return;
        const newLevel = cond.level + delta;
        if (newLevel < 0 || newLevel > maxLevel) return;
        cond.level = newLevel;
        buildConditionTabs();
        renderConditionTab();
        render(); // Full render to update stats
        await post({action: "modify_condition", name: name, level: newLevel});
    }

    function renderListArray(data, elId, label) {
        const box = document.getElementById(elId);
        const arr = parseList(data);
        if (arr.length > 0) { box.innerHTML = (label ? `<div class="lang-label">${label}</div>` : "") + arr.join("<br>"); box.style.display = "block"; } 
        else { box.style.display = "none"; }
    }

    function showSpeedDetails() {
        const c = state.character;
        let text = "";
        const modes = [{k:'Speed',l:'Land'},{k:'Speed_Swim',l:'Swim'},{k:'Speed_Climb',l:'Climb'},{k:'Speed_Fly',l:'Fly'},{k:'Speed_Burrow',l:'Burrow'}];
        let count = 0;
        modes.forEach(m => {
            const val = parseInt(c[m.k]) || 0;
            if (val > 0) { text += `<b>${m.l}:</b> ${val} ft.<br>`; count++; }
        });
        if (count === 0) text = "No movement speeds defined.";
        showInfoModal("Movement Speeds", text);
    }

    // ITEM & SHOP RENDER LOGIC
    function setItemSubTab(tab) {
        currentItemSubTab = tab;
        document.querySelectorAll('#view-items .sub-tab-btn').forEach(b => {
            b.classList.toggle('active', b.textContent.trim() === tab);
        });
        ['Inventory', 'Equipment', 'Shop'].forEach(t => {
            document.getElementById('item-view-'+t).style.display = (t === tab) ? 'block' : 'none';
        });
        if(tab === 'Shop') renderShop();
    }

    function renderList(elId, items) {
        const el = document.getElementById(elId);
        el.innerHTML = "";
        items = parseList(items);
        if (!items || !items.length) { el.innerHTML = "<div style='color:#666;font-style:italic;'>Empty</div>"; return; }
        if (typeof items[0] === 'string') items = items.map(i => ({name: i, qty: 1}));
        items.forEach(item => {
            let desc = "No description.", price = 0;
            if(state.db.consumables && state.db.consumables[item.name]) { 
                const d = state.db.consumables[item.name];
                desc = getDBValue(d, "description") || desc;
                price = getDBValue(d, "price") || price; 
            }
            if(item.specials) desc = "Specials: " + item.specials.join(", ");
            const row = document.createElement('div');
            row.className = 'item-row';
            row.innerHTML = `<span class="item-name" onclick="showInfoModal('${esc(item.name)}', '${esc(desc)}')">${item.name}</span>
                <span class="qty-badge" onclick="openQtyModal('${esc(item.name)}', ${item.qty||1}, ${price||0})">x${item.qty||1}</span>`;
            el.appendChild(row);
        });
    }

    function renderShop() {
        const el = document.getElementById('shopList');
        el.innerHTML = "";
        if(!state.db.consumables) return;
        Object.entries(state.db.consumables).forEach(([name, d]) => {
            const desc = getDBValue(d, "description") || "No description.";
            const price = getDBValue(d, "price") || 0;
            const row = document.createElement('div');
            row.className = 'item-row'; row.style.cursor="default";
            row.innerHTML = `<div><strong class="item-name" onclick="showInfoModal('${esc(name)}','${esc(desc)}')">${name}</strong><br><small style="color:#888">${price} gp</small></div>
                <div><button class="btn-add" onclick="buy('${esc(name)}',0)">Add</button><button class="btn-buy" onclick="buy('${esc(name)}',${price})">Buy</button></div>`;
            el.appendChild(row);
        });
    }

    function openResourceModal(type) {
        currentResType = type;
        const c = state.character;
        
        const bodyGeneric = document.getElementById('resBodyGeneric');
        const bodyHP = document.getElementById('resBodyHP');
        const bodyAC = document.getElementById('resBodyAC');
        bodyGeneric.style.display = "none";
        bodyHP.style.display = "none";
        bodyAC.style.display = "none";

        if (type === "HP") {
            document.getElementById('resTitle').innerText = "Manage Hit Points";
            refreshHPModalFields();
            bodyHP.style.display = "block";
        } 
        else if (type === "AC") {
            document.getElementById('resTitle').innerText = "Equipment";
            bodyAC.style.display = "block";
            document.getElementById('checkArmor').checked = c.Armor_Equipped !== false;
            document.getElementById('checkShield').checked = c.Shield_Equipped !== false;
        }
        else {
            bodyGeneric.style.display = "block";
            let val = 0;
            if (type === "Gold") { document.getElementById('resTitle').innerText = "Manage Gold"; val = parseFloat(c.Gold).toFixed(2); }
            else if (type === "Shield") { document.getElementById('resTitle').innerText = "Manage Shield HP"; val = parseInt(c.HP_Shield_Current) || 0; }
            document.getElementById('resCurrent').innerText = val;
            document.getElementById('resInput').value = "";
        }

        document.getElementById('resModal').style.display = 'flex';
    }
    
    async function toggleEquip(type) {
        const key = type + "_Equipped";
        const isChecked = document.getElementById('check'+type).checked;
        state.character[key] = isChecked;
        render();
        await post({action: "set_stat", key: key, value: isChecked});
    }

    function closeResModal() { document.getElementById('resModal').style.display = 'none'; }
    function getHpInputVal(id) {
        const input = document.getElementById(id);
        return parseFloat(input.value);
    }

    function refreshHPModalFields() {
        const hp = parseInt(state.character.HP_Current) || 0;
        const temp = parseInt(state.character.HP_Temp) || 0;
        if (document.getElementById('resCurrentHP')) document.getElementById('resCurrentHP').innerText = hp;
        if (document.getElementById('resCurrentTemp')) document.getElementById('resCurrentTemp').innerText = temp;
        if (document.getElementById('hpInput')) document.getElementById('hpInput').value = "";
        if (document.getElementById('tempInput')) document.getElementById('tempInput').value = "";
    }

    async function modifyHP(key, multiplier) {
        const val = key === "HP_Current" ? getHpInputVal('hpInput') : getHpInputVal('tempInput');
        if (isNaN(val) || val <= 0) return;
        const current = parseFloat(state.character[key]) || 0;
        const next = key === "HP_Temp" ? Math.max(0, current + (val * multiplier)) : current + (val * multiplier);
        state.character[key] = next;
        render();
        refreshHPModalFields(); 
        await post({action: "modify_stat", key: key, amount: val * multiplier});
    }

    async function setHPValue(key) {
        const val = key === "HP_Current" ? getHpInputVal('hpInput') : getHpInputVal('tempInput');
        if (isNaN(val)) return;
        state.character[key] = key === "HP_Temp" ? Math.max(0, val) : val;
        render();
        refreshHPModalFields();
        await post({action: "set_stat", key: key, value: state.character[key]});
    }

    async function modifyResource(multiplier) {
        const input = document.getElementById('resInput');
        const amount = parseFloat(input.value);
        if (!amount || amount <= 0) return;
        let key = "", current = 0, change = amount * multiplier;
        if (currentResType === "Gold") { 
            key = "Gold"; 
            current = parseFloat(state.character.Gold) || 0; 
            state.character.Gold = (current + change).toFixed(2); 
        }
        else if (currentResType === "Shield") { key = "HP_Shield_Current"; current = parseInt(state.character.HP_Shield_Current) || 0; state.character.HP_Shield_Current = Math.max(0, current + change); }
        render();
        document.getElementById('resCurrent').innerText = state.character[key];
        await post({action: "modify_stat", key: key, amount: change});
    }
    async function setResource() {
        const input = document.getElementById('resInput');
        const val = parseFloat(input.value);
        if (isNaN(val)) return;
        let key = "";
        if (currentResType === "Gold") { key = "Gold"; state.character.Gold = val.toFixed(2); } 
        else if (currentResType === "Shield") { key = "HP_Shield_Current"; state.character.HP_Shield_Current = Math.max(0, parseInt(val)); }
        render();
        document.getElementById('resCurrent').innerText = state.character[key];
        closeResModal(); 
        await post({action: "set_stat", key: key, value: val});
    }
    
    async function buy(name, price) {
        let qtyInput = prompt(`Enter quantity for ${name}:`, "1");
        if (qtyInput === null) return;
        let qty = parseInt(qtyInput);
        if (isNaN(qty) || qty <= 0) return;

        let currentGold = parseFloat(state.character.Gold) || 0;
        let total = 0;
        if (price > 0) {
            total = price * qty;
            if (currentGold < total) { alert("Not enough gold!"); return; }
            if (!confirm(`Buy ${qty} x ${name} for ${total} gp?`)) return;
            state.character.Gold = (currentGold - total).toFixed(2);
            await post({action: "set_stat", key: "Gold", value: state.character.Gold});
        }

        let list = parseList(state.character.Inventory_Consumables);
        if(!Array.isArray(list)) list=[];
        if(typeof list[0] === 'string') list = list.map(i=>({name:i, qty:1})); 
        let item = list.find(i=>i.name===name);
        if(item) item.qty=(parseInt(item.qty)||1)+qty; else list.push({name:name, qty:qty});
        state.character.Inventory_Consumables = list;
        render();
        
        await post({action: "adjust_qty", itemName: name, delta: qty});
    }

    function openQtyModal(n,q,p) { currentEditItem=n; document.getElementById('qTitle').innerText=n; document.getElementById('qValue').innerText=q; document.getElementById('qPrice').innerText=p; document.getElementById('qtyModal').style.display='flex'; }
    function closeQtyModal() { document.getElementById('qtyModal').style.display='none'; }
    function restockFromModal() { buy(currentEditItem, parseFloat(document.getElementById('qPrice').innerText)); document.getElementById('qValue').innerText = parseInt(document.getElementById('qValue').innerText)+1; }
    async function adjustQty(delta) {
        const disp = document.getElementById('qValue'); disp.innerText = Math.max(0, parseInt(disp.innerText)+delta);
        let list = parseList(state.character.Inventory_Consumables);
        if(typeof list[0] === 'string') list = list.map(i=>({name:i, qty:1}));
        let item = list.find(i=>i.name===currentEditItem);
        if(item) { item.qty = (parseInt(item.qty)||0)+delta; if(item.qty<=0) { list = list.filter(i=>i.name!==currentEditItem); closeQtyModal(); } }
        state.character.Inventory_Consumables = list; render(); await post({action: "adjust_qty", itemName: currentEditItem, delta: delta});
    }

    async function post(payload) { 
        // Add current character name to identify who to update in backend
        if (state.character && state.character.Name) {
            payload.charName = state.character.Name;
        }
        try { await fetch(API_URL, { method: "POST", mode: "no-cors", headers: {"Content-Type": "text/plain"}, body: JSON.stringify(payload) }); } 
        catch(e) { console.error("Sync Error", e); } 
    }
    
    function showInfoModal(t,b) {
        if (!b) b = ""; // Safety catch
        document.getElementById('mTitle').innerText=t; 
        document.getElementById('mDesc').innerHTML=formatText(b)||""; 
        document.getElementById('mFooter').innerHTML = ""; // Clear dynamic buttons
        document.getElementById('infoModal').style.display='flex'; 
    }
    
    function setText(id,v) { if(document.getElementById(id)) document.getElementById(id).innerText=(v!==undefined&&v!=="")?v:"0"; }
    function setTab(n) { document.querySelectorAll('.view-section').forEach(x=>x.classList.remove('active')); document.querySelectorAll('.tab-btn').forEach(x=>x.classList.remove('active')); document.getElementById('view-'+n).classList.add('active'); event.target.classList.add('active'); }

    window.onload = init;
</script>
</body>
</html>